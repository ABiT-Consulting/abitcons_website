name: Deploy to cPanel

on:
  push:
    branches:
      - main
  workflow_dispatch: {}

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Trigger cPanel deployment and wait
        shell: bash
        env:
          CPANEL_HOST: ${{ secrets.CPANEL_HOST }}
          CPANEL_PORT: ${{ secrets.CPANEL_PORT }}
          CPANEL_USER: ${{ secrets.CPANEL_USER }}
          CPANEL_TOKEN: ${{ secrets.CPANEL_TOKEN }}
          CPANEL_REPO_ROOT: ${{ secrets.CPANEL_REPO_ROOT }}
          # Optional. Defaults to "main".
          CPANEL_BRANCH: ${{ secrets.CPANEL_BRANCH }}
          # Set to "true" only if your cPanel TLS cert/hostname causes curl SSL errors.
          CPANEL_INSECURE: ${{ secrets.CPANEL_INSECURE }}
        run: |
          set -euo pipefail

          : "${CPANEL_HOST:?Missing secret CPANEL_HOST (example: server.example.com)}"
          : "${CPANEL_USER:?Missing secret CPANEL_USER (your cPanel username)}"
          : "${CPANEL_TOKEN:?Missing secret CPANEL_TOKEN (cPanel API token)}"
          : "${CPANEL_REPO_ROOT:?Missing secret CPANEL_REPO_ROOT (absolute path to the cPanel git repo)}"

          port="${CPANEL_PORT:-2083}"
          branch="${CPANEL_BRANCH:-main}"
          base="https://${CPANEL_HOST}:${port}"

          auth_header="Authorization: cpanel ${CPANEL_USER}:${CPANEL_TOKEN}"
          curl_flags=(-sS)
          if [[ "${CPANEL_INSECURE:-}" == "true" ]]; then
            curl_flags+=(-k)
          fi

          if ! command -v jq >/dev/null 2>&1; then
            echo "::error::jq is required but not found on the runner."
            exit 1
          fi

          cpanel_get() {
            local endpoint="$1"; shift
            local out="$1"; shift
            local url="${base}/execute/${endpoint}"
            local err
            err="$(mktemp)"

            local cmd=(curl "${curl_flags[@]}" -H "$auth_header" -H "Accept: application/json" --get)
            local kv
            for kv in "$@"; do
              cmd+=(--data-urlencode "$kv")
            done
            cmd+=("$url" -o "$out" -w "%{http_code}")

            set +e
            local code
            code="$("${cmd[@]}" 2>"$err")"
            local rc=$?
            set -e

            if (( rc != 0 )); then
              echo "::error::curl failed for ${endpoint} (rc=${rc})"
              sed -n '1,200p' "$err" || true
              if [[ -s "$out" ]]; then
                echo "---- response ----"
                sed -n '1,200p' "$out" || true
                echo "---- end ----"
              fi
              return 1
            fi

            if [[ "$code" =~ ^[0-9]+$ ]] && (( code >= 400 )); then
              echo "::error::HTTP ${code} from ${endpoint}"
              if [[ -s "$out" ]]; then
                echo "---- response ----"
                sed -n '1,200p' "$out" || true
                echo "---- end ----"
              fi
              return 1
            fi

            return 0
          }

          jq_ok_or_dump() {
            local file="$1"
            if ! jq . "$file" >/dev/null 2>&1; then
              echo "::error::Response was not valid JSON."
              sed -n '1,200p' "$file" || true
              return 1
            fi
            return 0
          }

          jq_status_or_error() {
            local file="$1"
            local endpoint="$2"
            if ! jq -e '.result.status == 1' "$file" >/dev/null 2>&1; then
              echo "::error::${endpoint} returned status != 1"

              # Include a compact excerpt of the raw JSON response (useful when .result.* keys are missing).
              raw="$(jq -c '.' "$file" 2>/dev/null || true)"
              if [[ -n "${raw:-}" && "${raw:-null}" != "null" ]]; then
                raw="${raw:0:1500}"
                echo "::error::Response(excerpt): ${raw}"
              fi

              # cPanel often returns useful context in metadata.reason even when errors/messages are empty.
              meta="$(jq -c '.result.metadata // {}' "$file" 2>/dev/null || true)"
              if [[ -n "${meta:-}" && "${meta:-null}" != "null" && "${meta:-}" != "{}" ]]; then
                echo "::error::Metadata: ${meta}"
              fi

              reason="$(jq -r '.result.metadata.reason // empty' "$file" 2>/dev/null || true)"
              if [[ -n "${reason:-}" && "${reason:-null}" != "null" ]]; then
                echo "::error::Reason: ${reason}"
              fi

              errors_json="$(jq -c '.result.errors // empty' "$file" 2>/dev/null || true)"
              if [[ -n "${errors_json:-}" && "${errors_json:-null}" != "null" && "${errors_json:-}" != "[]" ]]; then
                echo "::error::Errors: ${errors_json}"
              fi

              messages_json="$(jq -c '.result.messages // empty' "$file" 2>/dev/null || true)"
              if [[ -n "${messages_json:-}" && "${messages_json:-null}" != "null" && "${messages_json:-}" != "[]" ]]; then
                echo "::error::Messages: ${messages_json}"
              fi
              return 1
            fi
            return 0
          }

          echo "Updating cPanel repo (branch=${branch}): ${CPANEL_REPO_ROOT}"
          update_resp="$(mktemp)"
          cpanel_get "VersionControl/update" "$update_resp" \
            "repository_root=${CPANEL_REPO_ROOT}" \
            "branch=${branch}"
          jq_ok_or_dump "$update_resp"
          jq . "$update_resp"
          did_update=1
          if ! jq_status_or_error "$update_resp" "VersionControl/update"; then
            # Some cPanel setups disallow this call; deployment may still work via VersionControlDeployment/create.
            did_update=0
          fi

          if (( did_update )); then
            deployable="$(jq -r '.result.data.deployable // 0' "$update_resp")"
            deployable_reason="$(jq -r '.result.data.deployable_reason // empty' "$update_resp")"
            if [[ "$deployable" != "1" ]]; then
              echo "::error::Repository is not deployable. ${deployable_reason}"
              exit 1
            fi
          fi

          echo "Triggering cPanel deploy for repo: ${CPANEL_REPO_ROOT}"
          create_resp="$(mktemp)"
          cpanel_get "VersionControlDeployment/create" "$create_resp" \
            "repository_root=${CPANEL_REPO_ROOT}"
          jq_ok_or_dump "$create_resp"
          jq . "$create_resp"
          jq_status_or_error "$create_resp" "VersionControlDeployment/create"

          deploy_id="$(jq -r '.result.data.deploy_id // empty' "$create_resp")"
          log_path="$(jq -r '.result.data.log_path // empty' "$create_resp")"
          if [[ -z "$deploy_id" || "$deploy_id" == "null" ]]; then
            echo "Missing deploy_id in response."
            exit 1
          fi

          echo "Deployment queued: deploy_id=${deploy_id}"
          echo "Deployment log path: ${log_path}"

          # Poll deployment status until success/failure.
          deadline=$((SECONDS + 300))
          while true; do
            retrieve_resp="$(mktemp)"
            cpanel_get "VersionControlDeployment/retrieve" "$retrieve_resp"
            jq_ok_or_dump "$retrieve_resp"
            jq_status_or_error "$retrieve_resp" "VersionControlDeployment/retrieve" || true

            entry="$(jq -c --arg id "$deploy_id" '.result.data[]? | select((.deploy_id|tostring) == $id) | . // empty' "$retrieve_resp" | head -n1 || true)"
            if [[ -z "$entry" ]]; then
              echo "Waiting for deploy_id=${deploy_id} to appear..."
            else
              echo "$entry" | jq .

              succeeded="$(echo "$entry" | jq -r '.timestamps.succeeded // empty')"
              failed="$(echo "$entry" | jq -r '.timestamps.failed // empty')"
              canceled="$(echo "$entry" | jq -r '.timestamps.canceled // empty')"

              if [[ -n "$succeeded" ]]; then
                ident="$(echo "$entry" | jq -r '.repository_state.identifier // empty')"
                branch="$(echo "$entry" | jq -r '.repository_state.branch // empty')"
                echo "cPanel deploy: success (branch=${branch}, commit=${ident})"
                exit 0
              fi

              if [[ -n "$failed" || -n "$canceled" ]]; then
                echo "cPanel deploy: failed (deploy_id=${deploy_id})"
                echo "Deployment log path: ${log_path}"

                # Best effort: fetch and print the deployment log.
                if [[ -n "$log_path" && "$log_path" != "null" ]]; then
                  log_dir="$(dirname "$log_path")"
                  log_file="$(basename "$log_path")"

                  log_resp="$(mktemp)"
                  cpanel_get "Fileman/get_file_content" "$log_resp" \
                    "dir=${log_dir}" \
                    "file=${log_file}" \
                    "to_charset=utf-8" || true

                  echo "---- cPanel deploy log (tail) ----"
                  jq -r '.result.data.content // empty' "$log_resp" | tail -n 200 || true
                  echo "---- end ----"
                fi

                exit 1
              fi
            fi

            if (( SECONDS >= deadline )); then
              echo "Timed out waiting for cPanel deployment to complete (deploy_id=${deploy_id})."
              echo "Deployment log path: ${log_path}"
              exit 1
            fi

            sleep 3
          done
